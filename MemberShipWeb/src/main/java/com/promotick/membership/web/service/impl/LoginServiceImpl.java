package com.promotick.membership.web.service.impl;

import com.promotick.membership.common.ConstantesApi;
import com.promotick.membership.model.Token;
import com.promotick.membership.web.service.LogService;
import com.promotick.membership.web.service.LoginService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Map;
import java.util.Properties;

@Service
@Slf4j
public class LoginServiceImpl implements LoginService {

    @Autowired
    @Qualifier("propertiesPromotickConfig")
    private Properties properties;

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private LogService logService;

    private final RestTemplate restTemplate = new RestTemplate();
    private String tokenCache;
    private LocalDateTime tokenExpiracion;
    private String tokenType;
    private String tokenScope;
    private String usuario;

    @Override
    public String obtenerToken() {
        try {
            log.info("üîç Verificando token en cache...");
            log.info("üìã Token cache actual: " + (tokenCache != null ? "EXISTE" : "NULL"));
            log.info("üìã Token expiraci√≥n: " + tokenExpiracion);
            
            if (tokenEsValido()) {
                log.info("‚úÖ Usando token desde cache");
                log.info("‚è∞ Expira en: " + ChronoUnit.MINUTES.between(LocalDateTime.now(), tokenExpiracion)
                        + " minutos");
                return tokenCache;
            }
            
            log.info("üîÑ Token no v√°lido - Generando nuevo token...");
            // Si no hay token v√°lido, obtener uno nuevo
            String nuevoToken = generarToken();
            log.info("üéØ Nuevo token generado: " + (nuevoToken != null ? "√âXITO" : "FALL√ì"));
            return nuevoToken;
        } catch (Exception e) {
            log.error("‚ùå Error obteniendo token: " + e.getMessage());
            return null;
        }
    }

    /**
     * Limpiar cache del token
     */
    public void limpiarCache() {
        log.info("üóëÔ∏è LLAMADA A limpiarCache() - Stack trace:");
        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
        for (int i = 2; i < Math.min(6, stackTrace.length); i++) {
            log.info("   " + stackTrace[i].toString());
        }
        
        this.tokenCache = null;
        this.tokenExpiracion = null;
        this.tokenType = null;
        this.tokenScope = null;
        log.info("üóëÔ∏è Cache del token limpiado");
    }

    private String procesarRespuestaToken(ResponseEntity<Token> response) {
        log.info("üîç Procesando respuesta del token...");
        log.info("üìã Status Code: " + response.getStatusCode());
        log.info("üìã Tiene Body: " + (response.getBody() != null));
        
        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            Token token = response.getBody();
            log.info("üìã Access Token existe: " + (token.getAccessToken() != null));
            
            if (token.getAccessToken() != null) {
                log.info("‚úÖ Token v√°lido encontrado - Guardando en cache");
                // Guardar token en cache
                this.tokenCache = token.getAccessToken();
                this.tokenType = token.getTokenType();
                this.tokenScope = token.getScope();
                
                log.info("üìã Token guardado en cache: " + (this.tokenCache != null ? "S√ç" : "NO"));
                log.info("üìã Token type: " + this.tokenType);
                log.info("üìã Token scope: " + this.tokenScope);

                // Calcular expiraci√≥n basada en expires_in
                Integer expiresIn = token.getExpiresIn();
                log.info("üìã Expires in (segundos): " + expiresIn);
                
                if (expiresIn != null) {
                    this.tokenExpiracion = LocalDateTime.now().plusSeconds(expiresIn);
                } else {
                    // Valor por defecto: 1 hora
                    this.tokenExpiracion = LocalDateTime.now().plusHours(1);
                }
                
                log.info("üìã Token expirar√°: " + this.tokenExpiracion);
                return this.tokenCache;
            } else {
                log.error("‚ùå No se encontr√≥ access_token en la respuesta");
            }
        } else {
            log.error("‚ùå Respuesta inv√°lida: " + response.getStatusCode());
        }
        return null;
    }

    /**
     * Obtener identificador del cache si est√° v√°lido
     */
    public String obtenerUsuario() {
        if (usuario != null) {
            return usuario;
        }
        // No llamar a logout() aqu√≠ - solo devolver null si no hay usuario
        // logout() limpia el cache del token que puede ser v√°lido para otras operaciones
        return null;
    }

    /**
     * Guardar identificador en cache
     */
    public void guardarUsuario(String identificador) {
        this.usuario = identificador;
        log.info("‚úÖ Usuario guardado en cache: " + identificador);
    }

    /**
     * Limpiar cache del identificador
     */
    @Override
    public void logout() {
        this.usuario = null;
        this.limpiarCache();
    }

    @Override
    public Object loguearCedula(String cedula) {
        log.info("üîê Procesando login con c√©dula: " + cedula);
        Object resultado = null;
        
        String token = this.obtenerToken();

//                hacerConsultaPOST("/recompensas/v1/login", new HashMap<>(), cedula);
//
//        // Si el login es exitoso, guardar el identificador en cache
//        if (resultado instanceof JsonNode) {
//            JsonNode jsonNode = (JsonNode) resultado;
//            // Verificar si NO es un error (no tiene code de error)
//            if (!jsonNode.has("code") || jsonNode.get("code").asInt() < 400) {
//                log.info("‚úÖ Login exitoso - Guardando identificador en cache");
//                guardarIdentificador(cedula);
//            }
//        }

        return resultado;

    }




    /**
     * Verificar si el token en cache es v√°lido
     */
    private boolean tokenEsValido() {
        return tokenCache != null
                && tokenExpiracion != null
                && LocalDateTime.now().isBefore(tokenExpiracion.minusMinutes(5)); // Renovar 5 min antes de expirar
    }

    private String generarToken() {
        // Usar URL base de configuraci√≥n + endpoint de token
        String baseUrl = properties.getProperty(ConstantesApi.RECOMPENSAS_URL_BASE_TOKEN);
        String tokenUrl = baseUrl + ConstantesApi.RECOMPENSAS_API_TOKEN;
        log.info("üöÄ Solicitando token din√°mico...");
        log.info("üîó Base URL: " + baseUrl);
        log.info("üîó Token URL: " + tokenUrl);
        log.info("üîë Client ID: " + properties.getProperty(ConstantesApi.RECOMPENSAS_CLIENT_ID));
        HttpHeaders headers = new HttpHeaders();
        try {
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
            headers.set("Accept", "application/json");
            // Construir form data como key-value pairs (igual que en Postman)
            MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
            formData.add("grant_type", properties.getProperty(ConstantesApi.RECOMPENSAS_GRANT_TYPE));
            formData.add("client_id", properties.getProperty(ConstantesApi.RECOMPENSAS_CLIENT_ID));
            formData.add("client_secret", properties.getProperty(ConstantesApi.RECOMPENSAS_CLIENT_SECRET));
            log.info("üì§ Form Data (key-value pairs):");
            formData.forEach((key, value) -> log.info("   " + key + " = " + value.get(0)));

            HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(formData, headers);

            ResponseEntity<Token> response = restTemplate.exchange(
                    tokenUrl, HttpMethod.POST, request,
                    new org.springframework.core.ParameterizedTypeReference<Token>() {
                    });

            log.info("üì® Respuesta recibida del servidor de tokens");
            String resultado = procesarRespuestaToken(response);
            log.info("üéØ Resultado final del procesamiento: " + (resultado != null ? "√âXITO" : "FALL√ì"));
            return resultado;

        } catch (HttpClientErrorException e) {
            logService.generarLog("POST", e.getMessage(), tokenUrl, headers, "");
            log.error("‚ùå Error HTTP " + e.getStatusCode() + ": " + e.getResponseBodyAsString());
            log.error("‚ùå Headers de respuesta: " + e.getResponseHeaders());
            log.error("‚ùå Mensaje completo: " + e.getMessage());
            return null;
        } catch (Exception e) {
            logService.generarLog("POST", e.getMessage(), tokenUrl, headers, "");
            log.error("‚ùå Error obteniendo token din√°mico: " + e.getMessage());
            log.error("‚ùå Tipo de excepci√≥n: " + e.getClass().getSimpleName());
            e.printStackTrace();
            return null;
        }
    }

}
