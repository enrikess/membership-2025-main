package com.promotick.membership.web.service.impl;

import com.promotick.membership.common.ConstantesApi;
import com.promotick.membership.model.Token;
import com.promotick.membership.web.service.LogService;
import com.promotick.membership.web.service.LoginService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Map;
import java.util.Properties;

@Service
@Slf4j
public class LoginServiceImpl implements LoginService {

    @Autowired
    @Qualifier("propertiesPromotickConfig")
    private Properties properties;

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private LogService logService;

    private final RestTemplate restTemplate = new RestTemplate();
    private String tokenCache;
    private LocalDateTime tokenExpiracion;
    private String tokenType;
    private String tokenScope;
    private String usuario;

    @Override
    public String obtenerToken() {
        try {
            if (tokenEsValido()) {
                log.info("‚úÖ Usando token desde cache");
                log.info("‚è∞ Expira en: " + ChronoUnit.MINUTES.between(LocalDateTime.now(), tokenExpiracion)
                        + " minutos");
                return tokenCache;
            }
            // Si no hay token v√°lido, obtener uno nuevo
            String nuevoToken = generarToken();
            return nuevoToken;
        } catch (Exception e) {
            log.error("‚ùå Error obteniendo token: " + e.getMessage());
            return null;
        }
    }

    /**
     * Limpiar cache del token
     */
    public void limpiarCache() {
        this.tokenCache = null;
        this.tokenExpiracion = null;
        this.tokenType = null;
        this.tokenScope = null;
        log.info("üóëÔ∏è Cache del token limpiado");
    }

    private String procesarRespuestaToken(ResponseEntity<Token> response) {
        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            Token token = response.getBody();
            if (token.getAccessToken() != null) {
                // Guardar token en cache
                this.tokenCache = token.getAccessToken();
                this.tokenType = token.getTokenType();
                this.tokenScope = token.getScope();

                // Calcular expiraci√≥n basada en expires_in
                Integer expiresIn = token.getExpiresIn();
                if (expiresIn != null) {
                    this.tokenExpiracion = LocalDateTime.now().plusSeconds(expiresIn);
                } else {
                    // Valor por defecto: 1 hora
                    this.tokenExpiracion = LocalDateTime.now().plusHours(1);
                }
                return this.tokenCache;
            } else {
                log.error("‚ùå No se encontr√≥ access_token en la respuesta");
            }
        } else {
            log.error("‚ùå Respuesta inv√°lida: " + response.getStatusCode());
        }
        return null;
    }

    /**
     * Obtener identificador del cache si est√° v√°lido
     */
    public String obtenerUsuario() {
        if (usuario != null) {
            return usuario;
        }
        logout();
        return null;
    }

    /**
     * Limpiar cache del identificador
     */
    @Override
    public void logout() {
        this.usuario = null;
        this.limpiarCache();
    }

    @Override
    public Object loguearCedula(String cedula) {
        log.info("üîê Procesando login con c√©dula: " + cedula);
        Object resultado = null;
        
        String token = this.obtenerToken();

//                hacerConsultaPOST("/recompensas/v1/login", new HashMap<>(), cedula);
//
//        // Si el login es exitoso, guardar el identificador en cache
//        if (resultado instanceof JsonNode) {
//            JsonNode jsonNode = (JsonNode) resultado;
//            // Verificar si NO es un error (no tiene code de error)
//            if (!jsonNode.has("code") || jsonNode.get("code").asInt() < 400) {
//                log.info("‚úÖ Login exitoso - Guardando identificador en cache");
//                guardarIdentificador(cedula);
//            }
//        }

        return resultado;

    }




    /**
     * Verificar si el token en cache es v√°lido
     */
    private boolean tokenEsValido() {
        return tokenCache != null
                && tokenExpiracion != null
                && LocalDateTime.now().isBefore(tokenExpiracion.minusMinutes(5)); // Renovar 5 min antes de expirar
    }

    private String generarToken() {
        // Usar URL base de configuraci√≥n + endpoint de token
        String baseUrl = properties.getProperty(ConstantesApi.RECOMPENSAS_URL_BASE_TOKEN);
        String tokenUrl = baseUrl + ConstantesApi.RECOMPENSAS_API_TOKEN;
        log.info("üöÄ Solicitando token din√°mico...");
        log.info("üîó Base URL: " + baseUrl);
        log.info("üîó Token URL: " + tokenUrl);
        log.info("üîë Client ID: " + properties.getProperty(ConstantesApi.RECOMPENSAS_CLIENT_ID));
        HttpHeaders headers = new HttpHeaders();
        try {
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
            headers.set("Accept", "application/json");
            // Construir form data como key-value pairs (igual que en Postman)
            MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
            formData.add("grant_type", properties.getProperty(ConstantesApi.RECOMPENSAS_GRANT_TYPE));
            formData.add("client_id", properties.getProperty(ConstantesApi.RECOMPENSAS_CLIENT_ID));
            formData.add("client_secret", properties.getProperty(ConstantesApi.RECOMPENSAS_CLIENT_SECRET));
            log.info("üì§ Form Data (key-value pairs):");
            formData.forEach((key, value) -> log.info("   " + key + " = " + value.get(0)));

            HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(formData, headers);

            ResponseEntity<Token> response = restTemplate.exchange(
                    tokenUrl, HttpMethod.POST, request,
                    new org.springframework.core.ParameterizedTypeReference<Token>() {
                    });

            return procesarRespuestaToken(response);

        } catch (HttpClientErrorException e) {
            logService.generarLog("POST", e.getMessage(), tokenUrl, headers, "");
            log.error("‚ùå Error HTTP " + e.getStatusCode() + ": " + e.getResponseBodyAsString());
            return null;
        } catch (Exception e) {
            logService.generarLog("POST", e.getMessage(), tokenUrl, headers, "");
            log.error("‚ùå Error obteniendo token din√°mico: " + e.getMessage());
            return null;
        }
    }

}
